#!/bin/env python3

import argparse
import hashlib
from pathlib import Path
import re
import subprocess
import sys

def trace2addresses(filepath):
    """ scans the trace file (the given Path) for a line starting with
    "Backtrace:" and extracts the addresses in that backtrace to a list. """

    matched_line = ""

    with filepath.open() as f:
        for line in f:
            if not line.startswith("Backtrace:"):
                continue

            matched_line = line
            break

    cleaned_line = matched_line.replace("Backtrace:", "").strip()
    elements = [e for e in cleaned_line.split(" ") if e]

    addresses = []
    pattern = r"0x[0-9a-f]+:0x[0-9a-f]+"
    for element in elements:
        if not re.match(pattern, element):
            print(f"Error: '{element:s}' does not match the expected format.")
            continue

        address = element.split(":")[0]
        addresses.append(address)

    return addresses

def find_checksum(filepath):
    """ the firmware spits out the beginning of the SHA256 checksum of the ELF
    file that the firmware was built from. this function extracts that info
    from the trace file (the given Path). """

    with filepath.open() as f:
        for line in f:
            res = re.match(r".*SHA256:[ \t]*([0-9a-fA-F]+)", line)
            if not res is None:
                return res.group(1)

    return ""

def calculate_sha256(filepath):
    sha256_hash = hashlib.sha256()

    with open(filepath, "rb") as f:
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)

    return sha256_hash.hexdigest()

def file_exists(filename):
    """ validate if a regular file exists at the given path. """

    file_path = Path(filename)

    if not file_path.is_file():
        print(f"ERROR: No regular file exists at '{filename:s}'")
        sys.exit(1)

    return file_path

def main():
    descr = 'Decoder for ESP32 backtraces generated by firmware of the OpenDTU(-OnBattery) project'
    parser = argparse.ArgumentParser(description=descr)
    parser.add_argument('--elf', type=file_exists, required=True, help='Path to ELF file')
    parser.add_argument('--trace', type=file_exists, required=True, help='Path to backtrace file')
    parser.add_argument('--platform', type=lambda s: s.lower(), choices=["esp32s3", "esp32"],
            default="esp32s3", help='Platform (default: %(default)s)')

    args = parser.parse_args()

    elf = args.elf
    trace = args.trace
    platform = args.platform

    platformio = Path.home() / ".platformio"
    if not platformio.is_dir():
        print(f"Platformio seems not to be installed, '{platformio:s}' is not a directory")
        sys.exit(1)

    packages = platformio / "packages"
    if not packages.is_dir():
        print(f"What kind of System or Platformio installation is this? '{packages:s}' is not a directory")
        sys.exit(1)

    tools = packages / f"toolchain-xtensa-{platform:s}"
    if not tools.is_dir():
        print(f"Have you ever built for '{platform:s}'? Not a directory: '{tools:s}'")
        sys.exit(1)

    tools = tools / "bin"
    if not tools.is_dir():
        print(f"Not a directory: '{tools:s}', that's weird...")
        sys.exit(1)

    addr2line = tools / f"xtensa-{platform:s}-elf-addr2line"
    if not addr2line.is_file():
        print(f"Expected to find '{addr2line:s}', but there is no such file.")
        sys.exit(1)

    addresses = trace2addresses(trace)
    subprocess.run([addr2line, "--pretty-print", "--functions",
        "--inlines", "--addresses", "--demangle", "--exe", elf] + addresses)

    trace_checksum = find_checksum(trace)
    if not trace_checksum:
        print("WARNING: could not find checksum in trace file")

    elf_checksum = calculate_sha256(elf)
    if not elf_checksum.startswith(trace_checksum):
        print(f"WARNING: trace file checksum '{trace_checksum:s}' refers to a different ELF file.")
        print(f"         we are working with ELF file with checksum '{elf_checksum:s}'.")

if __name__ == '__main__':
    main()
